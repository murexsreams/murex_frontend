// Mock API service for development and testing\n\nimport {\n  Track,\n  User,\n  Artist,\n  Investment,\n  Comment,\n  Portfolio,\n  ApiResponse,\n  PaginatedResponse,\n  LoginRequest,\n  LoginResponse,\n  CreateTrackRequest,\n  CreateInvestmentRequest,\n  CreateCommentRequest,\n  SearchRequest,\n  Genre,\n} from '../types';\n\nimport {\n  mockTracks,\n  mockUsers,\n  mockArtists,\n  mockInvestments,\n  mockComments,\n  mockPortfolio,\n  getMockTrackById,\n  getMockUserById,\n  getMockArtistById,\n  getMockTracksByGenre,\n  getMockTrendingTracks,\n} from '../data/mockData';\n\n// Simulate network delay\nconst delay = (ms: number = 500) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Mock API responses\nclass MockApiService {\n  // Authentication\n  async login(request: LoginRequest): Promise<ApiResponse<LoginResponse>> {\n    await delay();\n    \n    // Simple mock authentication\n    const user = mockUsers.find(u => u.email === request.email);\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          code: 'INVALID_CREDENTIALS',\n          message: 'Invalid email or password',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        user,\n        accessToken: 'mock-access-token',\n        refreshToken: 'mock-refresh-token',\n        expiresIn: 3600,\n      },\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async logout(): Promise<ApiResponse<void>> {\n    await delay(200);\n    return {\n      success: true,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Tracks\n  async getTracks(params?: {\n    page?: number;\n    pageSize?: number;\n    genre?: Genre;\n    search?: string;\n  }): Promise<ApiResponse<PaginatedResponse<Track>>> {\n    await delay();\n    \n    let tracks = [...mockTracks];\n    \n    // Apply filters\n    if (params?.genre) {\n      tracks = tracks.filter(track => track.genre === params.genre);\n    }\n    \n    if (params?.search) {\n      const query = params.search.toLowerCase();\n      tracks = tracks.filter(track => \n        track.title.toLowerCase().includes(query) ||\n        track.artist.stageName.toLowerCase().includes(query) ||\n        track.tags.some(tag => tag.toLowerCase().includes(query))\n      );\n    }\n    \n    // Pagination\n    const page = params?.page || 1;\n    const pageSize = params?.pageSize || 20;\n    const startIndex = (page - 1) * pageSize;\n    const endIndex = startIndex + pageSize;\n    const paginatedTracks = tracks.slice(startIndex, endIndex);\n    \n    return {\n      success: true,\n      data: {\n        items: paginatedTracks,\n        pagination: {\n          page,\n          pageSize,\n          total: tracks.length,\n          totalPages: Math.ceil(tracks.length / pageSize),\n          hasNext: endIndex < tracks.length,\n          hasPrevious: page > 1,\n        },\n      },\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async getTrackById(id: string): Promise<ApiResponse<Track>> {\n    await delay();\n    \n    const track = getMockTrackById(id);\n    \n    if (!track) {\n      return {\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'Track not found',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    return {\n      success: true,\n      data: track,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async getTrendingTracks(): Promise<ApiResponse<Track[]>> {\n    await delay();\n    \n    return {\n      success: true,\n      data: getMockTrendingTracks(),\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async createTrack(request: CreateTrackRequest): Promise<ApiResponse<Track>> {\n    await delay(1000);\n    \n    // Mock track creation\n    const newTrack: Track = {\n      id: `track-${Date.now()}`,\n      title: request.title,\n      artist: mockArtists[0], // Use first artist as default\n      artistId: mockArtists[0].id,\n      duration: 0, // Will be set after audio upload\n      audioUrl: '',\n      coverArt: 'https://picsum.photos/300/300?random=' + Date.now(),\n      genre: request.genre,\n      tags: request.tags,\n      description: request.description,\n      fundingGoal: request.fundingGoal,\n      currentFunding: 0,\n      minimumInvestment: request.minimumInvestment,\n      totalShares: Math.floor(request.fundingGoal / 10), // $10 per share\n      availableShares: Math.floor(request.fundingGoal / 10),\n      sharePrice: 10,\n      expectedROI: request.expectedROI,\n      streamingProjections: {\n        monthlyStreams: 5000,\n        projectedGrowth: 5.0,\n        revenuePerStream: 0.004,\n        projectedMonthlyRevenue: 20,\n        projectedYearlyRevenue: 240,\n      },\n      status: 'draft' as any,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      socialStats: {\n        plays: 0,\n        likes: 0,\n        comments: 0,\n        shares: 0,\n        saves: 0,\n      },\n      investments: [],\n      totalInvestors: 0,\n    };\n\n    return {\n      success: true,\n      data: newTrack,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Investments\n  async getInvestments(userId: string): Promise<ApiResponse<Investment[]>> {\n    await delay();\n    \n    const investments = mockInvestments.filter(inv => inv.investorId === userId);\n    \n    return {\n      success: true,\n      data: investments,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async createInvestment(request: CreateInvestmentRequest): Promise<ApiResponse<Investment>> {\n    await delay(1500); // Simulate payment processing\n    \n    const track = getMockTrackById(request.trackId);\n    const investor = getMockUserById('user-5'); // Mock investor\n    \n    if (!track || !investor) {\n      return {\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'Track or investor not found',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    const shares = Math.floor(request.amount / track.sharePrice);\n    \n    const newInvestment: Investment = {\n      id: `investment-${Date.now()}`,\n      investorId: investor.id,\n      investor,\n      trackId: track.id,\n      track,\n      amount: request.amount,\n      shares,\n      sharePrice: track.sharePrice,\n      currentValue: request.amount, // Initially same as investment\n      totalReturns: 0,\n      roi: 0,\n      status: 'confirmed' as any,\n      investedAt: new Date(),\n      lastUpdated: new Date(),\n      paymentMethod: request.paymentMethod as any,\n    };\n\n    return {\n      success: true,\n      data: newInvestment,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async getPortfolio(userId: string): Promise<ApiResponse<Portfolio>> {\n    await delay();\n    \n    if (userId === 'user-5') {\n      return {\n        success: true,\n        data: mockPortfolio,\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    // Return empty portfolio for other users\n    const emptyPortfolio: Portfolio = {\n      userId,\n      totalValue: 0,\n      totalInvested: 0,\n      totalReturns: 0,\n      totalROI: 0,\n      investments: [],\n      performanceHistory: [],\n      genreDistribution: [],\n      artistDistribution: [],\n      lastUpdated: new Date(),\n    };\n\n    return {\n      success: true,\n      data: emptyPortfolio,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Social Features\n  async getComments(trackId: string): Promise<ApiResponse<Comment[]>> {\n    await delay();\n    \n    const comments = mockComments.filter(comment => comment.trackId === trackId);\n    \n    return {\n      success: true,\n      data: comments,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async createComment(request: CreateCommentRequest): Promise<ApiResponse<Comment>> {\n    await delay();\n    \n    const user = getMockUserById('user-5'); // Mock current user\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: 'User not authenticated',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    const newComment: Comment = {\n      id: `comment-${Date.now()}`,\n      trackId: request.trackId,\n      userId: user.id,\n      user,\n      content: request.content,\n      timestamp: request.timestamp || 0,\n      likes: 0,\n      replies: [],\n      flagged: false,\n      hidden: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    return {\n      success: true,\n      data: newComment,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async likeTrack(trackId: string): Promise<ApiResponse<void>> {\n    await delay(200);\n    \n    // In a real app, this would update the like status in the database\n    return {\n      success: true,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async followArtist(artistId: string): Promise<ApiResponse<void>> {\n    await delay(300);\n    \n    return {\n      success: true,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Search\n  async search(request: SearchRequest): Promise<ApiResponse<{\n    tracks: Track[];\n    artists: Artist[];\n    users: User[];\n  }>> {\n    await delay();\n    \n    const query = request.query.toLowerCase();\n    \n    const tracks = mockTracks.filter(track =>\n      track.title.toLowerCase().includes(query) ||\n      track.artist.stageName.toLowerCase().includes(query) ||\n      track.tags.some(tag => tag.toLowerCase().includes(query))\n    );\n    \n    const artists = mockArtists.filter(artist =>\n      artist.stageName.toLowerCase().includes(query) ||\n      (artist.realName && artist.realName.toLowerCase().includes(query))\n    );\n    \n    const users = mockUsers.filter(user =>\n      user.displayName.toLowerCase().includes(query) ||\n      user.username.toLowerCase().includes(query)\n    );\n\n    return {\n      success: true,\n      data: {\n        tracks: tracks.slice(0, 10),\n        artists: artists.slice(0, 5),\n        users: users.slice(0, 5),\n      },\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Artists\n  async getArtists(): Promise<ApiResponse<Artist[]>> {\n    await delay();\n    \n    return {\n      success: true,\n      data: mockArtists,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  async getArtistById(id: string): Promise<ApiResponse<Artist>> {\n    await delay();\n    \n    const artist = getMockArtistById(id);\n    \n    if (!artist) {\n      return {\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'Artist not found',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    return {\n      success: true,\n      data: artist,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Users\n  async getUserById(id: string): Promise<ApiResponse<User>> {\n    await delay();\n    \n    const user = getMockUserById(id);\n    \n    if (!user) {\n      return {\n        success: false,\n        error: {\n          code: 'NOT_FOUND',\n          message: 'User not found',\n        },\n        timestamp: new Date().toISOString(),\n      };\n    }\n\n    return {\n      success: true,\n      data: user,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  // Analytics (mock data)\n  async getTrackAnalytics(trackId: string): Promise<ApiResponse<any>> {\n    await delay();\n    \n    const mockAnalytics = {\n      totalPlays: Math.floor(Math.random() * 100000),\n      uniqueListeners: Math.floor(Math.random() * 50000),\n      averageListenDuration: Math.floor(Math.random() * 180) + 60,\n      completionRate: Math.random() * 0.4 + 0.6, // 60-100%\n      topCountries: [\n        { country: 'United States', plays: Math.floor(Math.random() * 20000), percentage: 35 },\n        { country: 'United Kingdom', plays: Math.floor(Math.random() * 10000), percentage: 18 },\n        { country: 'Canada', plays: Math.floor(Math.random() * 8000), percentage: 12 },\n      ],\n      dailyPlays: Array.from({ length: 30 }, (_, i) => ({\n        date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000),\n        plays: Math.floor(Math.random() * 1000) + 100,\n        uniqueListeners: Math.floor(Math.random() * 500) + 50,\n      })),\n    };\n\n    return {\n      success: true,\n      data: mockAnalytics,\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n// Export singleton instance\nexport const mockApiService = new MockApiService();\n\n// Helper function to simulate API errors\nexport const simulateApiError = (errorCode: string, message: string) => {\n  return {\n    success: false,\n    error: {\n      code: errorCode,\n      message,\n    },\n    timestamp: new Date().toISOString(),\n  };\n};\n\n// Helper function to create paginated response\nexport const createPaginatedResponse = <T>(\n  items: T[],\n  page: number,\n  pageSize: number\n): PaginatedResponse<T> => {\n  const startIndex = (page - 1) * pageSize;\n  const endIndex = startIndex + pageSize;\n  const paginatedItems = items.slice(startIndex, endIndex);\n  \n  return {\n    items: paginatedItems,\n    pagination: {\n      page,\n      pageSize,\n      total: items.length,\n      totalPages: Math.ceil(items.length / pageSize),\n      hasNext: endIndex < items.length,\n      hasPrevious: page > 1,\n    },\n  };\n};"